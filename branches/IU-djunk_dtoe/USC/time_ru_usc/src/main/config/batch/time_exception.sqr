!***********************************************************************
!  TIME_EXCEPTION.SQR -- Populate exception tables with timesheet
!                        exceptions.
!***********************************************************************
!  Programmer  :  Jim Nelson
!  Date        :  2006-MAY-26
!  Project Name:
!  Description :
!  Notes       :
!
!
!***********************************************************************
!  INDIANA UNIVERSITY MODIFICATION HISTORY
!***********************************************************************
!  Programmer  :
!  Date        :
!  Description :
!
!***********************************************************************


!***********************************************************************
begin-report
  do Main
end-report
!***********************************************************************


!***********************************************************************
! Procedure Name : Main
! Description    : Variable initialization performed here
!***********************************************************************
begin-procedure Main

BEGIN-SELECT
to_char(SYSDATE-1,'YYYYMMDD') &yesterday
to_char(SYSDATE,  'YYYYMMDD') &today
to_char(SYSDATE+1,'YYYYMMDD') &tomorrow

  let $yesterday = &yesterday
  let $today     = &today
  let $tomorrow  = &tomorrow

  !let $yesterday = '20060530'
  !let $today     = '20060531'
  show 'yesterday ' $yesterday
  show 'today     ' $today
  show 'tomorrow  ' $tomorrow

  let $min_earliest_time_block_start = $yesterday || ' 00:00:00'
  let $max_latest_time_block_end = $yesterday || ' 23:59:59'

FROM DUAL
END-SELECT


!asn ! A. Neal - Code added for Testing                                              !asn
!asn                                                                                 !asn    
!asn let $asn_date       = '20061009'                                                !asn
!asn                                                                                 !asn
!asn while 1=1                                                                       !asn
!asn   add 1 to #i                                                                   !asn
!asn   if #i > 14                                                                    !asn
!asn     break                                                                       !asn
!asn   end-if                                                                        !asn
!asn                                                                                 !asn
!asn begin-select                                                                    !asn
!asn to_char((to_date($asn_date,'yyyymmdd') - 1),'yyyymmdd') &asn_yesterday          !asn
!asn to_char(to_date($asn_date,'yyyymmdd'),'yyyymmdd') &asn_today                    !asn
!asn to_char((to_date($asn_date,'yyyymmdd') + 1),'yyyymmdd') &asn_tomorrow           !asn
!asn from dual                                                                       !asn
!asn end-select                                                                      !asn
!asn                                                                                 !asn
!asn   let $yesterday = &asn_yesterday                                               !asn
!asn   let $today     = &asn_today                                                   !asn   
!asn   let $asn_date  = &asn_tomorrow                                                !asn
!asn                                                                                 !asn
!asn   let $min_earliest_time_block_start = $yesterday || ' 00:00:00'                !asn 
!asn   let $max_latest_time_block_end = $yesterday || ' 23:59:59'                    !asn
!asn                                                                                 !asn
!asn                                                                                 !asn
!asn   show '-----------------------------------'                                    !asn
!asn   show 'yesterday ' $yesterday                                                  !asn
!asn   show 'today ' $today                                                          !asn
!asn   show '-----------------------------------'                                    !asn

do Get-Distinct-Clock-Log-Empls-Thru-Work-Area

!asn begin-sql                                                                       !asn
!asn commit                                                                          !asn
!asn end-sql                                                                         !asn
!asn                                                                                 !asn 
!asn end-while                                                                       !asn


end-procedure ! Main



!***********************************************************************
! Procedure Name : Get-Distinct-Clock-Log-Empls-Thru-Work-Area
! Description    : Break Rule Exceptions are define by emplid/empl_rcd/
!                  work_area_id/dept. Get a distinct list of those
!                  values from the clock log, within the reporting range
!                  of interest. This list will then be used to find
!                  the appropriate break rule (if one exists).
!***********************************************************************
begin-procedure Get-Distinct-Clock-Log-Empls-Thru-Work-Area

show 'In Get-Distinct-Clock-Log-Empls-Thru-Work-Area'

BEGIN-SELECT DISTINCT
CL_TWA.EMPLID
CL_TWA.EMPL_RCD
CL_TWA.WORK_AREA_ID
WAT.DEPTID

  let $emplid                         = &CL_TWA.EMPLID
  let #empl_rcd                       = &CL_TWA.EMPL_RCD
  let #work_area_id                   = &CL_TWA.WORK_AREA_ID
  let $deptid                         = &WAT.DEPTID

  do Find-Best-Match-Break-Rule

FROM TK_CLOCK_LOG_T CL_TWA, TK_WORK_AREA_T WAT
WHERE CL_TWA.CLOCK_TS BETWEEN to_date($min_earliest_time_block_start,'YYYYMMDD hh24:mi:ss') AND to_date($max_latest_time_block_end,'YYYYMMDD hh24:mi:ss')
AND WAT.WORK_AREA_ID = CL_TWA.WORK_AREA_ID
AND WAT.EFFDT = (SELECT MAX(WATD.EFFDT) FROM TK_WORK_AREA_T WATD WHERE WATD.WORK_AREA_ID=WAT.WORK_AREA_ID AND WATD.EFFDT <= to_date($min_earliest_time_block_start,'YYYYMMDD hh24:mi:ss'))
AND WAT.EFFSEQ = (SELECT MAX(WATS.EFFSEQ) FROM TK_WORK_AREA_T WATS WHERE WATS.WORK_AREA_ID=WAT.WORK_AREA_ID AND WATS.EFFDT = WAT.EFFDT)
AND WAT.EFF_STATUS = 'A'
AND CL_TWA.CLOCK_ACTION_CD IN ('BO','BI')
ORDER BY CL_TWA.EMPLID,
         CL_TWA.EMPL_RCD,
         CL_TWA.WORK_AREA_ID
END-SELECT

end-procedure ! Get-Distinct-Clock-Log-Empls-Thru-Work-Area



!***********************************************************************
! Procedure Name : Find-Best-Match-Break-Rule
! Description    : Part of finding a rule is to find the most closely
!                  matching rule. We'll build successfully less-restrictive
!                  WHERE clauses until we find a matching rule (or don't
!                  find one at all, which is fine)
!***********************************************************************
begin-procedure Find-Best-Match-Break-Rule

show 'In Find-Best-Match-Break-Rule'

let $found_matching_rule = 'N'

!Most selective rule uses emplid/empl_rcd/work_area_id/deptid
let $where_clause = 'AND BRT.EMPLID = ''' || $emplid || ''' AND BRT.EMPL_RCD = ' || to_char(#empl_rcd) || ' AND BRT.WORK_AREA_ID = ' || to_char(#work_area_id) || ' AND BRT.DEPTID = ''' || $deptid || ''''
do Find-Break-Rule

if ($found_matching_rule = 'N')
  !no luck, so look based on empld/work_area_id/deptid (-1 is empl_rcd wildcard)
  !let $where_clause = 'AND BRT.EMPLID = ''' || $emplid || ''' AND BRT.WORK_AREA_ID = ' || to_char(#work_area_id) || ' AND BRT.DEPTID = ''' || $deptid || ''''
  let $where_clause = 'AND BRT.EMPLID = ''' || $emplid || ''' AND BRT.EMPL_RCD = -1 AND BRT.WORK_AREA_ID = ' || to_char(#work_area_id) || ' AND BRT.DEPTID = ''' || $deptid || ''''
  do Find-Break-Rule
end-if


if ($found_matching_rule = 'N')
  !no luck, so look based on work_area_id/deptid (@ is emplid wildcard, -1 is empl_rcd wildcard)
  !let $where_clause = 'AND BRT.WORK_AREA_ID = ' || to_char(#work_area_id) || ' AND BRT.DEPTID = ''' || $deptid || ''''
  let $where_clause = 'AND BRT.EMPLID = ''@'' AND BRT.EMPL_RCD = -1 AND BRT.WORK_AREA_ID = ' || to_char(#work_area_id) || ' AND BRT.DEPTID = ''' || $deptid || ''''
  do Find-Break-Rule
end-if

if ($found_matching_rule = 'N')
  !no luck, so look based on deptid (@ is emplid wildcard, -1 is empl_rcd wildcard, -1 is work_area_id wildcard)
  !let $where_clause = 'AND BRT.DEPTID = ''' || $deptid || ''''
  let $where_clause = 'AND BRT.EMPLID = ''@'' AND BRT.EMPL_RCD = -1 AND BRT.WORK_AREA_ID = -1 AND BRT.DEPTID = ''' || $deptid || ''''
  do Find-Break-Rule
end-if

! note that it's okay to not find a break rule

end-procedure   ! Find-Best-Match-Break-Rule


!***********************************************************************
! Procedure Name : Find-Break-Rule
! Description    : Get the details of a break rule and apply the rule
!                  to the clock log
!***********************************************************************
begin-procedure Find-Break-Rule

show 'In Find-Break-Rule'

let $cur_time_block_start = $min_earliest_time_block_start

BEGIN-SELECT
BRT.BLOCK_HRS
BRT.MAX_MINS
BRT.NUMBER_OF_BREAKS

  let $found_matching_rule            = 'Y'
  let #block_hrs                      = &BRT.BLOCK_HRS
  let #max_mins                       = &BRT.MAX_MINS
  let #number_of_breaks               = &BRT.NUMBER_OF_BREAKS

  show 'Found a rule:'
  show '  block_hrs = ' #block_hrs
  show '  max_mins  = ' #max_mins
  show '  number_of_breaks = ' #number_of_breaks

  let $done_with_blocks = 'N'
  while ($done_with_blocks = 'N')

    do Set-Block-Start-Stop-Times

    if ($done_with_blocks = 'Y')
      break
    end-if

    do Eval-Clock-Log-Against-Break-Rule

    let $cur_time_block_start = $cur_time_block_end

  end-while

FROM TK_BREAK_RL_T BRT
WHERE BRT.EFFDT = (SELECT MAX(BRTD.EFFDT)
                   FROM TK_BREAK_RL_T BRTD
                   WHERE BRTD.DEPTID = BRT.DEPTID
                     AND BRTD.WORK_AREA_ID = BRT.WORK_AREA_ID
                     AND BRTD.EMPLID = BRT.EMPLID
                     AND BRTD.EMPL_RCD = BRT.EMPL_RCD
                     AND BRTD.EFFDT <= to_date($today,'yyyymmdd'))
  AND BRT.EFFSEQ = (SELECT MAX(BRTS.EFFSEQ)
                    FROM TK_BREAK_RL_T BRTS
                    WHERE BRTS.DEPTID = BRT.DEPTID
                      AND BRTS.WORK_AREA_ID = BRT.WORK_AREA_ID
                      AND BRTS.EMPLID = BRT.EMPLID
                      AND BRTS.EMPL_RCD = BRT.EMPL_RCD
                      AND BRTS.EFFDT = BRT.EFFDT)
   AND BRT.EFF_STATUS = 'A'
   [$where_clause]
END-SELECT

end-procedure ! Find-Break-Rule



!***********************************************************************
! Procedure Name : Set-Block-Start-Stop-Times
! Description    : Break rules are applicable to time blocks, so we
!                  need to determine the block start and stop times.
!***********************************************************************
begin-procedure Set-Block-Start-Stop-Times

show 'In Set-Block-Start-Stop-Times'
show 'cur_time_block_start ' $cur_time_block_start
show 'max_latest_time_block_end ' $max_latest_time_block_end

let $cur_time_block_end = ''

!BLOCK START TIME
BEGIN-SELECT
to_char(MIN(BREAK_CLOCK_LOG_ST.CLOCK_TS),'yyyymmdd hh24:mi:ss') &BREAK_CLOCK_LOG_ST.tsstart

  let $cur_time_block_start = &BREAK_CLOCK_LOG_ST.tsstart

FROM TK_CLOCK_LOG_T BREAK_CLOCK_LOG_ST
WHERE BREAK_CLOCK_LOG_ST.EMPLID = $emplid
  AND BREAK_CLOCK_LOG_ST.EMPL_RCD = #empl_rcd
  AND BREAK_CLOCK_LOG_ST.WORK_AREA_ID = #work_area_id
  AND BREAK_CLOCK_LOG_ST.CLOCK_TS BETWEEN to_date($cur_time_block_start,'yyyymmdd hh24:mi:ss') AND to_date($max_latest_time_block_end,'yyyymmdd hh24:mi:ss')
  AND BREAK_CLOCK_LOG_ST.CLOCK_ACTION_CD IN ('CI','LI')
END-SELECT

show 'new cur_time_block_start ' $cur_time_block_start

!BLOCK END TIME
BEGIN-SELECT
to_char(MIN(BREAK_CLOCK_LOG_END.CLOCK_TS),'yyyymmdd hh24:mi:ss') &BREAK_CLOCK_LOG_END.tsend

  let $cur_time_block_end = &BREAK_CLOCK_LOG_END.tsend

FROM TK_CLOCK_LOG_T BREAK_CLOCK_LOG_END
WHERE BREAK_CLOCK_LOG_END.EMPLID = $emplid
  AND BREAK_CLOCK_LOG_END.EMPL_RCD = #empl_rcd
  AND BREAK_CLOCK_LOG_END.WORK_AREA_ID = #work_area_id
  AND BREAK_CLOCK_LOG_END.CLOCK_TS BETWEEN to_date($cur_time_block_start,'yyyymmdd hh24:mi:ss') AND to_date($max_latest_time_block_end,'yyyymmdd hh24:mi:ss')
  AND BREAK_CLOCK_LOG_END.CLOCK_ACTION_CD IN ('CO','LO')
END-SELECT

show 'new cur_time_block_end ' $cur_time_block_end

if ($cur_time_block_end = '')

  let $done_with_blocks = 'Y'

else ! we have a good block, what task is the empl working on?

BEGIN-SELECT
to_char(TASK.TASK_ID) &task.task_id

  let $task_id = &TASK.TASK_ID
  show 'task_id ' $task_id

FROM TK_CLOCK_LOG_T TASK
WHERE TASK.EMPLID = $emplid
  AND TASK.EMPL_RCD = #empl_rcd
  AND TASK.WORK_AREA_ID = #work_area_id
  AND TASK.CLOCK_TS = to_date($cur_time_block_start,'yyyymmdd hh24:mi:ss')
  AND TASK.CLOCK_ACTION_CD IN ('CI','LI')
END-SELECT

end-if

end-procedure ! Set-Block-Start-Stop-Times



!***********************************************************************
! Procedure Name : Eval-Clock-Log-Against-Break-Rule
! Description    : We have a rule, we have a time block for the log, so
!                  it's now possible to look for an exception
!***********************************************************************
begin-procedure Eval-Clock-Log-Against-Break-Rule

show 'In Eval-Clock-Log-Against-Break-Rule'

let #break_size = 0
let #break_count = 0
let #total_break_minutes = 0
let #block_size = datediff(strtodate($cur_time_block_end,'yyyymmdd hh24:mi:ss'),strtodate($cur_time_block_start,'yyyymmdd hh24:mi:ss'),'hour')

BEGIN-SELECT
COUNT(*) &break_count

  let #break_count    = &break_count

  show 'break count ' #break_count

  !----------------------------
  ! Check if number of allowed breaks has been exceeded
  !----------------------------
  if (#break_count > #number_of_breaks)
    let $exception_type = 'EBS'
    do Insert-Break-Exception
  end-if

  !----------------------------
  ! Check if block is big enough to allow breaks
  !----------------------------
  if (#block_size < #block_hrs)
    show 'Block is below block_hrs - insert exception'
    let $exception_type = 'EBS'
    let #break_count = -1
    do Insert-Break-Exception
  end-if

FROM TK_CLOCK_LOG_T
WHERE EMPLID       = $emplid
  AND EMPL_RCD     = #empl_rcd
  AND WORK_AREA_ID = #work_area_id
  AND CLOCK_ACTION_CD = 'BO'
  AND CLOCK_TS BETWEEN to_date($cur_time_block_start,'yyyymmdd hh24:mi:ss') AND to_date($cur_time_block_end,'yyyymmdd hh24:mi:ss')
END-SELECT

!----------------------------
! Check duration of breaks
!----------------------------
let #total_break_minutes = 0
BEGIN-SELECT
to_char(BREAK_CLOCK_LOG.CLOCK_TS,'yyyymmdd hh24:mi:ss') &ts
BREAK_CLOCK_LOG.CLOCK_ACTION_CD

  if (&BREAK_CLOCK_LOG.CLOCK_ACTION_CD = 'BO')
    let $break_out_ts = &ts
  end-if

  if (&BREAK_CLOCK_LOG.CLOCK_ACTION_CD = 'BI')
    let $break_in_ts = &ts
    let #total_break_minutes = #total_break_minutes + datediff(strtodate($break_in_ts,'yyyymmdd hh24:mi:ss'),strtodate($break_out_ts,'yyyymmdd hh24:mi:ss'),'minute')
  end-if


FROM TK_CLOCK_LOG_T BREAK_CLOCK_LOG
WHERE BREAK_CLOCK_LOG.EMPLID = $emplid
  AND BREAK_CLOCK_LOG.EMPL_RCD = #empl_rcd
  AND BREAK_CLOCK_LOG.WORK_AREA_ID = #work_area_id
  AND CLOCK_TS BETWEEN to_date($cur_time_block_start,'yyyymmdd hh24:mi:ss') AND to_date($cur_time_block_end,'yyyymmdd hh24:mi:ss')
ORDER BY BREAK_CLOCK_LOG.CLOCK_TS
END-SELECT

show 'total_break_minutes ' #total_break_minutes
show 'break minutes ' #max_mins

if (round(#total_break_minutes,0) > round(#max_mins,0))
  let $exception_type = 'EBT'
  do Insert-Break-Exception
end-if

end-procedure   ! Eval-Clock-Log-Against-Break-Rule



!***********************************************************************
! Procedure Name : Insert-Break-Exception
! Description    : SQL to insert an exception
!***********************************************************************
begin-procedure Insert-Break-Exception

do Get-Job-Effdt-And-Effseq

BEGIN-SQL ON-ERROR=SQL_Error 
INSERT INTO TK.TK_BREAK_EXCEPTION_T
(
EXCEPTION_DT,
EXCEPTION_TYPE,
EMPLID,
EMPL_RCD,
EFFDT,
EFFSEQ,
WORK_AREA_ID,
TASK_ID,
BLOCK_BEGIN_TS,
ACTUAL_MINUTES,
RULE_MINUTES,
ACTUAL_NUMBER_OF_BREAKS,
RULE_NUMBER_OF_BREAKS
)
VALUES
(
to_date($today,'yyyymmdd'),
$exception_type,
$emplid,
#empl_rcd,
TO_DATE($effdt,'yyyymmdd'),
#effseq,
to_char(#work_area_id),
$task_id,
to_date($cur_time_block_start,'yyyymmdd hh24:mi:ss'),
#total_break_minutes,
#max_mins,
#break_count,
#number_of_breaks)
END-SQL

end-procedure ! Insert-Break-Exception



!***********************************************************************
! Procedure Name : Get-Job-Effdt-And-Effseq
! Description    : Part of exception data is the effdt/effseq of the job
!                  so determine those here
!***********************************************************************
begin-procedure Get-Job-Effdt-And-Effseq

let $effdt = ''
let #effseq = 0

BEGIN-SELECT
TO_CHAR(J.EFFDT,'yyyymmdd') &j.effdt
J.EFFSEQ

  let $effdt = &j.effdt
  let #effseq = &j.effseq

FROM HRE.HRE_TK_JOB_T J
WHERE J.EMPLID=$emplid
  AND J.EMPL_RCD=#empl_rcd
  AND J.EFFDT = (SELECT MAX(JD.EFFDT) FROM HRE.HRE_TK_JOB_T JD WHERE JD.EMPLID=J.EMPLID AND JD.EMPL_RCD=J.EMPL_RCD AND JD.EFFDT<=to_date($yesterday,'YYYYMMDD'))
  AND J.EFFSEQ = (SELECT MAX(JS.EFFSEQ) FROM HRE.HRE_TK_JOB_T JS WHERE JS.EMPLID=J.EMPLID AND JS.EMPL_RCD=J.EMPL_RCD AND JS.EFFDT=J.EFFDT)

END-SELECT

end-procedure ! Get-Job-Effdt-And-Effseq


begin-procedure SQL_error

if substr($sql-error,1,9) = 'ORA-00001'
   ! ignore unique constraints
else
   Show 'SQL Error: ' $sql-error
   Show 'SQL Status: ' #sql-status
   stop
end-if

end-Procedure ! SQL_Error

